#include <stdio.h>

int main()
{
	int x[3] = {1,2,3};

	// 아래 2줄을 명확히 이해 하세요
	int (*p1)[3] = &x;		// 배열의 주소
	int *p2 	 = &x[0];	// 배열의 0번째 요소의 주소

	// p1, p2 는 같은 주소가 나오지만
	// 포인터 타입이 다르므로, 
	// 연산자를 사용시 연산하는 방법이 달라집니다.
	// #1. + 연산시
	printf("%p, %p\n", p1, p1 + 1); // 1000, 1012
	printf("%p, %p\n", p2, p2 + 1); // 1000, 1004

	// #2. * 연산시
	// *(int*)    => int 입니다.
	// *(double*) => double 입니다.

//	*p1 = 10; // "*(배열*) => 배열" 인데 배열 = 0 하므로 error
	(*p1)[0] = 10; // ok
	*p2 = 10; // *(int*) => int 이므로 ok.

	// * 연산은 [] 연산으로 표현가능합니다.
	// 따라서, 위 코드는 []로 표현하면
	p1[0][0] = 10;
	p2[0] = 10;

	// 결론, 1차배열이 있을때
	// 배열 자체의 주소(포인터)를 가지고 있으면 2차 배열처럼 사용하게 됩니다.
	// 배열의 요소의 주소(포인터)를 가지고 사용하면 1차 배열처럼 사용.

	// 그래서, C 언어 문법에
	// "배열의 이름의 배열의 주소" 가 아니고
	// "배열의 이름의 배열의 0번째 요소의 주소" 로 암시적 형변환 된다.
	// "array to pointer conversion"

	int* p3 = x;  // int* p3 = &x[0]  와 같은 코드
}